"""Recommendation API for the tourism recommender system."""

import math
from typing import List, Dict, Any, Optional, Tuple
from collections import defaultdict

from src.data_models import (
    RecommendationRequest,
    Recommendation,
    Context,
    UserProfile,
    LocationFeatures,
)
from src.ensemble_voting import EnsembleVotingSystem
from src.mobile_optimizer import MobileOptimizer
from src.logger import get_logger

# Get logger instance
logger = get_logger()


class RecommenderAPI:
    """Main API for generating recommendations."""
    
    def __init__(
        self,
        ensemble: EnsembleVotingSystem,
        optimizer: MobileOptimizer,
        destinations: Optional[Dict[str, LocationFeatures]] = None,
        user_profiles: Optional[Dict[str, UserProfile]] = None,
    ):
        """
        Initialize the recommender API.
        
        Args:
            ensemble: Ensemble voting system
            optimizer: Mobile optimizer for caching
            destinations: Dictionary mapping destination_id to LocationFeatures
            user_profiles: Dictionary mapping user_id to UserProfile
        """
        self.ensemble = ensemble
        self.optimizer = optimizer
        self.destinations = destinations or {}
        self.user_profiles = user_profiles or {}
        self._popular_destinations_cache: Optional[List[str]] = None
    
    def get_recommendations(
        self, request: RecommendationRequest, context: Context
    ) -> List[Recommendation]:
        """
        Generate personalized recommendations.
        
        Requirement 10.4: IF all models fail to generate predictions, THEN THE
        Recommender_System SHALL return popular destinations as fallback.
        
        Args:
            request: Recommendation request with user preferences
            context: Current context (weather, season, etc.)
            
        Returns:
            List of Recommendation objects
        """
        # Check cache first
        cache_key = self._build_cache_key(request, context)
        cached = self.optimizer.get_cached_recommendations(cache_key)
        if cached is not None:
            return cached
        
        # Handle invalid user (treat as cold start)
        user_id = request.user_id
        if user_id not in self.user_profiles:
            # Create cold start user profile
            self.user_profiles[user_id] = UserProfile(
                user_id=user_id,
                is_cold_start=True,
            )
            # Update context to reflect cold start
            context.user_type = 'cold_start'
        
        # Get candidate destinations
        candidate_items = list(self.destinations.keys())
        
        try:
            # Get ensemble predictions
            predictions = self.ensemble.predict(
                user_id=user_id,
                context=context,
                candidate_items=candidate_items,
                top_k=50,  # Get more than needed for filtering
            )
            
            # Check if predictions are valid
            if not predictions or len(predictions) == 0:
                raise ValueError("No predictions generated by ensemble")
            
        except Exception as e:
            # Fallback to popular destinations (Requirement 10.4)
            # Use structured logging (Requirement 10.5)
            logger.log_error(
                request_id=cache_key,
                error_type='ensemble_prediction_failure',
                error_message=str(e),
                context={
                    'user_id': user_id,
                    'n_candidates': len(candidate_items),
                    'context': {
                        'season': context.season,
                        'weather': context.weather.condition if context.weather else None,
                        'user_type': context.user_type
                    }
                }
            )
            
            logger.log_fallback(
                request_id=cache_key,
                fallback_type='popular_destinations',
                reason='All models failed to generate predictions',
                context={'error': str(e)}
            )
            
            predictions = self._get_popular_destinations_fallback(candidate_items)
        
        # Convert predictions to Recommendation objects
        recommendations = []
        for dest_id, score in predictions:
            if dest_id not in self.destinations:
                continue
            
            dest = self.destinations[dest_id]
            
            # Calculate distance if location provided
            distance_km = None
            if request.location:
                distance_km = self._calculate_distance(
                    request.location, (dest.latitude, dest.longitude)
                )
            
            # Estimate cost based on price range
            estimated_cost = self._estimate_cost(dest.price_range, request.group_size)
            
            # Generate explanation
            explanation = self.generate_explanation(dest, score, context)
            
            recommendations.append(
                Recommendation(
                    destination_id=dest_id,
                    name=dest.name,
                    score=score,
                    explanation=explanation,
                    distance_km=distance_km,
                    estimated_cost=estimated_cost,
                )
            )
        
        # Apply filters
        recommendations = self.apply_filters(recommendations, request)
        
        # Apply diversity-aware reranking
        recommendations = self.apply_diversity_reranking(recommendations)
        
        # Limit to requested number (default 10)
        top_k = 10  # Default from requirements
        recommendations = recommendations[:top_k]
        
        # Cache results
        self.optimizer.cache_recommendations(cache_key, recommendations)
        
        return recommendations
    
    def _get_popular_destinations_fallback(
        self, candidate_items: List[str]
    ) -> List[Tuple[str, float]]:
        """
        Get popular destinations as fallback when all models fail.
        
        Requirement 10.4: IF all models fail to generate predictions, THEN THE
        Recommender_System SHALL return popular destinations as fallback.
        
        Args:
            candidate_items: List of destination IDs
            
        Returns:
            List of (destination_id, score) tuples sorted by popularity
        """
        # Build or use cached popular destinations list
        if self._popular_destinations_cache is None:
            # Sort destinations by review count and average rating
            dest_scores = []
            for dest_id in candidate_items:
                if dest_id in self.destinations:
                    dest = self.destinations[dest_id]
                    # Popularity score = weighted combination of review count and rating
                    # Normalize review count to [0, 1] range (assume max 1000 reviews)
                    normalized_reviews = min(dest.review_count / 1000.0, 1.0)
                    # Normalize rating to [0, 1] range
                    normalized_rating = (dest.avg_rating - 1.0) / 4.0
                    # Combine: 60% review count, 40% rating
                    popularity_score = 0.6 * normalized_reviews + 0.4 * normalized_rating
                    dest_scores.append((dest_id, popularity_score))
            
            # Sort by popularity score descending
            dest_scores.sort(key=lambda x: x[1], reverse=True)
            
            # Cache the popular destinations
            self._popular_destinations_cache = [dest_id for dest_id, _ in dest_scores]
        
        # Return popular destinations with scores
        popular_predictions = []
        for i, dest_id in enumerate(self._popular_destinations_cache):
            if dest_id in candidate_items:
                # Assign decreasing scores based on popularity rank
                score = 1.0 - (i / len(self._popular_destinations_cache))
                popular_predictions.append((dest_id, score))
        
        logger.logger.info(f"Returning {len(popular_predictions)} popular destinations as fallback")
        
        return popular_predictions
    
    def apply_filters(
        self, recommendations: List[Recommendation], request: RecommendationRequest
    ) -> List[Recommendation]:
        """
        Apply budget and distance filters.
        
        Args:
            recommendations: List of recommendations to filter
            request: Request containing filter criteria
            
        Returns:
            Filtered list of recommendations
        """
        filtered = recommendations
        
        # Apply budget filter
        if request.budget is not None:
            budget_min, budget_max = request.budget
            filtered = [
                rec
                for rec in filtered
                if rec.estimated_cost is not None
                and budget_min <= rec.estimated_cost <= budget_max
            ]
        
        # Apply distance filter
        if request.max_distance_km is not None:
            filtered = [
                rec
                for rec in filtered
                if rec.distance_km is not None
                and rec.distance_km <= request.max_distance_km
            ]
        
        return filtered
    
    def apply_diversity_reranking(
        self, recommendations: List[Recommendation], diversity_weight: float = 0.3
    ) -> List[Recommendation]:
        """
        Rerank to ensure diverse destination types.
        
        This method ensures that the top recommendations include a variety of
        destination types (beach, cultural, nature, etc.) rather than all being
        of the same type.
        
        Args:
            recommendations: List of recommendations to rerank
            diversity_weight: Weight for diversity penalty (0.0 to 1.0)
            
        Returns:
            Reranked list of recommendations
        """
        if len(recommendations) < 2:
            return recommendations
        
        # Track selected destination types
        selected_types = []
        reranked = []
        
        # Create a working list
        remaining = recommendations.copy()
        
        while remaining:
            best_idx = 0
            best_score = -float('inf')
            
            for idx, rec in enumerate(remaining):
                # Get destination type
                dest_type = self._get_destination_type(rec.destination_id)
                
                # Calculate diversity bonus
                type_count = selected_types.count(dest_type)
                diversity_penalty = diversity_weight * type_count
                
                # Adjusted score
                adjusted_score = rec.score - diversity_penalty
                
                if adjusted_score > best_score:
                    best_score = adjusted_score
                    best_idx = idx
            
            # Add best item to reranked list
            selected = remaining.pop(best_idx)
            reranked.append(selected)
            
            # Track type
            dest_type = self._get_destination_type(selected.destination_id)
            selected_types.append(dest_type)
        
        return reranked
    
    def generate_explanation(
        self, destination: LocationFeatures, score: float, context: Context
    ) -> str:
        """
        Generate human-readable explanation for recommendation.
        
        Args:
            destination: Destination being recommended
            score: Recommendation score
            context: Current context
            
        Returns:
            Explanation string
        """
        explanations = []
        
        # Add location type
        explanations.append(f"This {destination.location_type} destination")
        
        # Add rating info
        if destination.avg_rating >= 4.0:
            explanations.append(f"has excellent reviews ({destination.avg_rating:.1f}/5)")
        
        # Add context-specific info
        if context.weather.condition in ['sunny', 'cloudy']:
            if destination.location_type == 'beach':
                explanations.append("perfect for the current weather")
        
        if context.is_holiday and destination.location_type == 'cultural':
            explanations.append("great for holiday exploration")
        
        # Add attributes
        if destination.attributes:
            attr_str = ", ".join(destination.attributes[:2])
            explanations.append(f"featuring {attr_str}")
        
        return " ".join(explanations) + "."
    
    def _build_cache_key(
        self, request: RecommendationRequest, context: Context
    ) -> str:
        """Build cache key from request and context."""
        return f"{request.user_id}_{request.location}_{context.weather.condition}_{context.season}"
    
    def _calculate_distance(
        self, loc1: Tuple[float, float], loc2: Tuple[float, float]
    ) -> float:
        """
        Calculate distance between two coordinates using Haversine formula.
        
        Args:
            loc1: (latitude, longitude) tuple
            loc2: (latitude, longitude) tuple
            
        Returns:
            Distance in kilometers
        """
        lat1, lon1 = loc1
        lat2, lon2 = loc2
        
        # Convert to radians
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        delta_lat = math.radians(lat2 - lat1)
        delta_lon = math.radians(lon2 - lon1)
        
        # Haversine formula
        a = (
            math.sin(delta_lat / 2) ** 2
            + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon / 2) ** 2
        )
        c = 2 * math.asin(math.sqrt(a))
        
        # Earth radius in kilometers
        radius = 6371.0
        
        return radius * c
    
    def _estimate_cost(self, price_range: str, group_size: int) -> float:
        """
        Estimate cost based on price range and group size.
        
        Args:
            price_range: 'budget', 'mid-range', or 'luxury'
            group_size: Number of people
            
        Returns:
            Estimated cost in local currency
        """
        # Base costs per person
        base_costs = {
            'budget': 50.0,
            'mid-range': 150.0,
            'luxury': 500.0,
        }
        
        base = base_costs.get(price_range, 150.0)
        return base * group_size
    
    def _get_destination_type(self, destination_id: str) -> str:
        """
        Get destination type for diversity calculation.
        
        Args:
            destination_id: Destination ID
            
        Returns:
            Destination type string
        """
        if destination_id in self.destinations:
            return self.destinations[destination_id].location_type
        return 'unknown'
